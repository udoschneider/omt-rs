# Unsafe Areas in the OMT High-Level Wrapper

## Overview

This document describes the unsafe areas in the OMT high-level Rust wrapper (`omt` crate) that are not covered by Rust's compile-time guarantees. The `omt` crate provides safe, idiomatic Rust bindings for the Open Media Transport (OMT) C library (`libomt`). While the wrapper aims to provide a safe API, it necessarily contains `unsafe` code to interface with the underlying C library.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Unsafe Code Categories](#unsafe-code-categories)
3. [Memory Safety Considerations](#memory-safety-considerations)
4. [Thread Safety Guarantees](#thread-safety-guarantees)
5. [Frame Lifetime Management](#frame-lifetime-management)
6. [Resource Management](#resource-management)
7. [Error Handling and Recovery](#error-handling-and-recovery)
8. [API Invariants and Preconditions](#api-invariants-and-preconditions)
9. [Testing and Validation](#testing-and-validation)
10. [Recommendations for Users](#recommendations-for-users)

## Architecture Overview

The OMT Rust wrapper consists of two crates:
- `omt-sys`: Low-level FFI bindings (generated by `bindgen`)
- `omt`: High-level safe wrapper

The high-level wrapper provides:
- RAII-based resource management (`Sender`, `Receiver`)
- Type-safe enums and structs
- Lifetime-bound frame data (`MediaFrame<'a>`)
- Error handling with `thiserror`

## Unsafe Code Categories

### 1. FFI Function Calls

All calls to C library functions are unsafe. The wrapper assumes the C library:
- Correctly implements its documented behavior
- Maintains thread safety for documented operations
- Properly manages its internal memory

**Example from `receiver.rs`:**
```rust
let handle = unsafe {
    omt_sys::omt_receive_create(
        c_address.as_ptr(),
        frame_types.to_ffi(),
        format.to_ffi(),
        flags.to_ffi(),
    )
};
```

**Safety Assumptions:**
- `omt_receive_create` returns a valid pointer or null
- The pointer remains valid until `omt_receive_destroy` is called
- The function doesn't have other side effects that violate Rust's safety rules

### 2. Raw Pointer Dereferencing

The wrapper dereferences raw pointers returned by the C API:

**Example from `frame/mod.rs`:**
```rust
pub(crate) unsafe fn from_ffi_ptr(ptr: *const omt_sys::OMTMediaFrame) -> Option<Self> {
    if ptr.is_null() {
        None
    } else {
        Some(Self {
            ffi: unsafe { *ptr },  // Dereferencing raw pointer
            _marker: PhantomData,
        })
    }
}
```

**Safety Assumptions:**
- The pointer is valid and properly aligned
- The pointed-to memory contains a valid `OMTMediaFrame`
- The structure fields are initialized according to C library expectations

### 3. Slice Creation from Raw Pointers

Frame data is exposed as Rust slices created from raw pointers:

**Example from `frame/mod.rs`:**
```rust
pub fn data(&self) -> &'a [u8] {
    if self.ffi.Data.is_null() || self.ffi.DataLength <= 0 {
        &[]
    } else {
        unsafe {
            slice::from_raw_parts(self.ffi.Data as *const u8, self.ffi.DataLength as usize)
        }
    }
}
```

**Safety Assumptions:**
- `Data` pointer is valid for the lifetime `'a`
- `DataLength` accurately reflects the allocated memory size
- The memory region is readable and doesn't alias mutable references
- The C library won't modify or free this memory while Rust references exist

### 4. Thread Safety Assertions

The wrapper uses `unsafe impl` to assert thread safety:

**Example from `receiver.rs`:**
```rust
// SAFETY: The underlying C library is thread-safe
unsafe impl Send for Receiver {}
unsafe impl Sync for Receiver {}
```

**Safety Assumptions:**
- The C library's `omt_receive_t` handle can be safely transferred between threads
- Concurrent calls to C functions with the same handle are properly synchronized
- The library doesn't use thread-local storage in an unsafe way

## Memory Safety Considerations

### 1. C Library Memory Management

The C library manages memory for:
- Frame data returned by `omt_receive()` and `omt_send_receive()`
- Discovery results from `omt_discovery_getaddresses()`
- Internal buffers for statistics and sender information

**Key Issues:**
- **Frame Data Lifetime**: Frames are only valid until the next receive call
- **Discovery Memory Leak**: The C library may leak memory from `omt_discovery_getaddresses()`
- **Unbounded Allocations**: The C library may allocate memory without size limits

### 2. Frame Data Borrowing

The `MediaFrame<'a>` type uses lifetime parameters to enforce safety:

```rust
pub struct MediaFrame<'a> {
    ffi: omt_sys::OMTMediaFrame,
    _marker: PhantomData<&'a ()>,
}
```

**Safety Guarantees:**
- Lifetime `'a` ties frame data to its source (`Receiver` or `Sender`)
- Prevents frames from outliving their source
- Prevents use-after-next-receive-call through `&self` borrows

**Remaining Risks:**
- The C library could invalidate frame data earlier than expected
- Concurrent modification by C library while Rust holds references
- Memory corruption in C library affecting pointer validity

### 3. String Handling

The wrapper converts C strings to Rust `String` types:

**Safety Measures:**
- Copies C strings to owned `String` values immediately
- Validates UTF-8 encoding
- Handles null pointers gracefully
- Uses `CString` for passing strings to C

**Example from `discovery.rs`:**
```rust
if let Ok(cstr) = CStr::from_ptr(ptr).to_str() {
    result.push(cstr.to_string());  // Copy to owned String
}
```

## Thread Safety Guarantees

### 1. Documented Thread Safety

The C library documentation states that:
- Different handles (`omt_receive_t`, `omt_send_t`) can be used concurrently
- Most functions are thread-safe for operations on different handles
- Some functions may have internal synchronization

**Wrapper Assumptions:**
- `Send` and `Sync` implementations are based on C library documentation
- No verification of actual thread safety implementation
- Users must not rely on undocumented thread safety properties

### 2. Concurrent Frame Access

**Safe Patterns:**
- Multiple threads can receive frames from different `Receiver` instances
- Multiple threads can send frames from different `Sender` instances
- Statistics queries can be called concurrently with frame operations

**Unsafe Patterns:**
- Concurrent calls to `receive()` on the same `Receiver` instance
- Concurrent calls to `send()` on the same `Sender` instance
- Modifying settings while operations are in progress

## Frame Lifetime Management

### 1. Receive Frame Lifetime

Frames returned by `Receiver::receive()` have a specific lifetime constraint:

```rust
pub fn receive(
    &self,
    frame_types: FrameType,
    timeout_ms: i32,
) -> Result<Option<MediaFrame<'_>>> {
    // ...
}
```

**Safety Contract:**
- Frame data is valid until the next `receive()` call on the same receiver
- The lifetime `'_` ties the frame to the `&self` receiver reference
- This prevents holding frames across `receive()` calls

**Implementation:**
```rust
// SAFETY: The C API guarantees the frame data is valid until the next call to omt_receive.
// The lifetime bound to &self ensures the frame cannot outlive this receiver instance
// and cannot be used after the next receive() call (due to &self borrow).
Ok(unsafe { MediaFrame::from_ffi_ptr(ptr) })
```

### 2. Owned Frame Lifetime

`OwnedMediaFrame` provides frames with owned data:

```rust
pub struct OwnedMediaFrame {
    data: Vec<u8>,
    frame_metadata: Option<CString>,
    // ... other fields
}
```

**Safety Advantages:**
- Complete ownership of frame data
- No dependency on C library memory management
- Can be safely stored and passed between threads

## Resource Management

### 1. RAII Wrappers

The wrapper uses RAII for C library resources:

```rust
impl Drop for Receiver {
    fn drop(&mut self) {
        unsafe {
            omt_sys::omt_receive_destroy(self.handle.as_ptr() as *mut _);
        }
    }
}
```

**Safety Considerations:**
- Assumes `omt_receive_destroy` is idempotent
- Assumes destruction doesn't have side effects affecting other instances
- No validation that destruction actually frees all resources

### 2. Handle Validity

The wrapper uses `NonNull` to track handle validity:

```rust
pub struct Receiver {
    handle: NonNull<omt_sys::omt_receive_t>,
}
```

**Safety Measures:**
- `NonNull` ensures handle is never null after construction
- Drop implementation ensures cleanup
- No cloning of handles to prevent double-free

## Error Handling and Recovery

### 1. C Library Error Reporting

The C library uses return codes and null pointers for errors:

**Wrapper Approach:**
- Converts null pointers to `Option::None` or `Result::Err`
- Maps C error codes to Rust error types
- Provides descriptive error messages

**Example from `receiver.rs`:**
```rust
NonNull::new(handle as *mut _)
    .map(|handle| Self { handle })
    .ok_or(Error::ReceiverCreateFailed)
```

### 2. Panic Safety

The wrapper aims to be panic-safe:

**Safe Operations:**
- FFI calls don't panic (they may abort on severe errors)
- String conversions handle invalid UTF-8 gracefully
- Null pointers are checked before dereferencing

**Potential Panic Sources:**
- Integer overflow in calculations
- Memory allocation failures
- Assertions in debug builds

## API Invariants and Preconditions

### 1. Documented Preconditions

The wrapper documents preconditions for safety:

**Example from `frame_builder.rs`:**
```rust
if self.width <= 0 || self.height <= 0 {
    return Err(Error::InvalidParameter {
        parameter: "dimensions".to_string(),
        reason: "width and height must be greater than zero".to_string(),
    });
}
```

### 2. Undocumented Invariants

Some invariants are assumed but not verified:

**C Library Invariants:**
- Structure padding matches Rust expectations
- Enum values are within documented ranges
- Pointer alignment requirements are met
- Memory ordering guarantees for concurrent access

## Testing and Validation

### 1. Unit Testing

The wrapper includes tests for:
- Type conversions between Rust and C representations
- Error handling edge cases
- Memory safety through example usage

**Limitations:**
- Cannot test C library implementation correctness
- Limited testing of concurrent access patterns
- No fuzz testing of C API boundary

### 2. Integration Testing

Examples demonstrate real usage patterns:

**Tested Scenarios:**
- Basic sender/receiver communication
- Frame conversion operations
- Discovery functionality
- Statistics collection

## Recommendations for Users

### 1. Safe Usage Patterns

**Recommended:**
```rust
// Process frames immediately
if let Some(frame) = receiver.receive(FrameType::VIDEO, 1000)? {
    process_frame(&frame);
    // Frame dropped here, before next receive()
}

// Use owned frames for storage
let owned_frame = video_builder.build()?;
let media_frame = owned_frame.as_media_frame();
// owned_frame keeps data alive
```

**Avoid:**
```rust
// DON'T: Store frames beyond their lifetime
let frame = receiver.receive(FrameType::VIDEO, 1000)?.unwrap();
std::thread::sleep(std::time::Duration::from_secs(2));
// UNSAFE: Frame may be invalid if receive() was called elsewhere
process_frame(&frame);
```

### 2. Concurrent Usage Guidelines

**Safe:**
- Use separate `Receiver`/`Sender` instances per thread
- Share statistics and tally data (they're `Copy`)
- Use channels to pass frames between threads

**Unsafe:**
- Sharing `Receiver`/`Sender` between threads without synchronization
- Concurrent frame processing from the same source
- Modifying settings concurrently with operations

### 3. Error Recovery

**Robust Error Handling:**
```rust
match receiver.receive(FrameType::VIDEO, 1000) {
    Ok(Some(frame)) => process_frame(&frame),
    Ok(None) => log::debug!("Timeout receiving frame"),
    Err(Error::Timeout) => reconnect_receiver(),
    Err(e) => log::error!("Fatal error: {}", e),
}
```

### 4. Memory Management

**Best Practices:**
- Monitor memory usage when processing many frames
- Consider using `OwnedMediaFrame` for long-lived frame data
- Be aware of potential memory leaks in C library
- Implement connection pooling for high-throughput applications

## Conclusion

The OMT high-level wrapper provides a safe interface to the underlying C library through careful use of `unsafe` code and Rust's type system. While most safety risks are mitigated through lifetime parameters, RAII, and input validation, users should be aware of the remaining areas where C library behavior affects safety:

1. **Frame lifetime dependencies** on C library implementation
2. **Thread safety assumptions** based on documentation rather than verification
3. **Memory management** relying on C library correctness
4. **Error recovery** limited by C library error reporting

By following the recommended usage patterns and understanding the safety boundaries, users can effectively use the OMT wrapper while minimizing risks associated with FFI integration.

---

*Last Updated: $(date)*  
*OMT Version: $(crate_version)*  
*libomt Version: $(libomt_version)*